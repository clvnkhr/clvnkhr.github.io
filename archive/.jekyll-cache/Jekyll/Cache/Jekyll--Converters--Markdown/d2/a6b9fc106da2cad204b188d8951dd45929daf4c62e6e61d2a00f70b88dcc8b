I"Ù$<p>The goal of Leetcode 69: Sqrt (Easy) is to provide your own implementation of integer square roots (rounded down), without appealing to a built in power operator or function.</p>

<p>One standard solution is binary search. But I was very amused to discover that one can avoid this with a mathematical device called a <a href="https://en.wikipedia.org/wiki/Pad√©_approximant">Pad√© approximant</a>, obtaining a reasonable run time without any knowledge of basic algorithms.
<img src="https://clvnkhr.github.io/assets/img/pade-runtime.png" alt="test" /></p>

<p>I was reminded of Pad√© approximants by this <a href="https://www.youtube.com/watch?v=szMaPkJEMrw">YouTube video</a>. Essentially, it is a variant Taylor series expansion that takes into account the asymyptotic order of the function, which improves accuracy away from the expansion point. Specifically, for any sufficiently nice function \(f\), its Pad√© approximant at \(x=0\) of order \((N,M)\) is the rational polynomial
\[ \frac{ \sum_{n=0}^N a_n x^n }{1 + \sum_{n=1}^M b_n x^n} \]
whose first \(N+M\) derivatives at \(x=0\) agree with those of \(f\).</p>

<p>There is <a href="https://shop.elsevier.com/books/essentials-of-pade-approximants/baker/978-0-12-074855-6">much to be said</a> about <a href="https://mathoverflow.net/questions/122539/the-unreasonable-effectiveness-of-pad√©-approximation">the magic of Pad√© approximants</a>, and I certainly haven‚Äôt read it all. Some questions about it can be found <a href="(https://math.stackexchange.com/questions/1474035/rigorous-rationale-for-the-pade-approximant)">here</a>.</p>

<p>Going back to Leetcode 69, the sketch of my solution is as follows. In order to compute the rounded square root of some number \(x\),</p>

<ol>
  <li>Find an approximate square \(s=r^2\) below \(x\) but not too far from the true answer</li>
  <li>use the percentage difference \(ds = (s-x)/s\) in the Pad√© approximation of order \((3,1)\) of \(\sqrt{1+t}\), which is
\[ \frac{-t^3/64 + 3t^2/16 + 9t/8 + 1}{5t/8 + 1} \]
This is related to computing \(\sqrt x\) via \(\sqrt x = r \sqrt{1 + ds}.\)</li>
  <li>Round down and check answer. If its not right, then fallback to something else (to emphasise how good the approximation is, I implemented a naive linear search from the point predicted by the Pad√© approximant.)</li>
</ol>

<p>Here‚Äôs the code. <a href="https://leetcode.com/problems/sqrtx/">do try it out</a>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">eh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="s">'''eh wtv'''</span>
        <span class="n">gg</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span class="n">g</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">gg</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">gg</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="ow">and</span> <span class="p">(</span><span class="n">g</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">g</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mySqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span>
        <span class="k">while</span> <span class="n">g2</span> <span class="o">*</span> <span class="n">g2</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">g2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">g2</span>
        
        <span class="k">if</span> <span class="n">g2</span><span class="o">*</span><span class="n">g2</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">g2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">eh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">g1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">g1</span>
        
        <span class="c1"># to get sqrt(x) we put x = g^2 ( 1 + ds) and use a Pad√© approximant 
</span>        <span class="c1"># where g is the closest guess
</span>        
        <span class="n">g</span> <span class="o">=</span> <span class="n">g1</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">g1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">g2</span><span class="p">)</span> <span class="k">else</span> <span class="n">g2</span>
        <span class="n">gg</span> <span class="o">=</span> <span class="n">g</span><span class="o">*</span><span class="n">g</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">gg</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">gg</span><span class="p">)</span>
        <span class="c1"># pade approximation to sqrt(1+x) of order (3,1) seems 'best'
</span>        <span class="n">pade_g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">9</span> <span class="o">*</span> <span class="n">ds</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">ds</span> <span class="o">*</span> <span class="n">ds</span><span class="p">)</span><span class="o">/</span><span class="mi">16</span> <span class="o">-</span> <span class="n">ds</span> <span class="o">*</span> <span class="n">ds</span> <span class="o">*</span> <span class="n">ds</span><span class="o">/</span><span class="mi">64</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">ds</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span>
        
        <span class="c1"># order (2,2):
</span>        <span class="c1"># pade_g = g * ((5 * ds * ds)/16 + (5 * ds)/4 + 1)/(ds * ds/16 + (3 * ds)/4 + 1)
</span>
        <span class="n">ipg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pade_g</span><span class="p">)</span>

        <span class="c1"># i've run out of math magic so just fumble around like a linear fool
</span>        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">eh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ipg</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ipg</span><span class="o">*</span><span class="n">ipg</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">ipg</span> <span class="o">=</span> <span class="n">ipg</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#else if itg*itg &gt; x:
</span>                <span class="n">ipg</span> <span class="o">=</span> <span class="n">ipg</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ipg</span>
</code></pre></div></div>

<p>Time permitting, I will come back to this and properly analyse the code, and see how well it performs if I fall back to say binary search instead.</p>
:ET