I"�)<p>Quick notes on pandas (<code class="highlighter-rouge">import pandas as pd</code>)</p>

<p>lets say df is a pd.DataFrame. to select we can use df[…], df.loc[…] or df.iloc[…]</p>

<p>df[…] can be used to select one or more columns by their names, or to select rows by a boolean mask.
df.loc[…] can be used to select rows and columns by their labels, or by a boolean mask. The labels can be the index or column names, or a range of them.</p>

<p>df[…] cannot be used to select rows and columns simultaneously, unless the rows are selected by a boolean mask, so</p>

<p>Note df[“colname”] and df.loc[“colname”] will return a series: to return a df, use a list of column names i.e. df[[“colname”]].</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># this will not work
</span><span class="n">df</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span><span class="s">'age'</span><span class="p">]</span>
</code></pre></div></div>

<p>df.iloc is loc but with indices instead of names.
There is also <code class="highlighter-rouge">df.query</code>, so <code class="highlighter-rouge">df.query("Salary == max_salary")</code> is equivalent to <code class="highlighter-rouge">df[df['Salary'] == max_salary]</code></p>

<table>
  <tbody>
    <tr>
      <td>In the boolean mask, and and or are replaced by &amp; and</td>
      <td>. In addition, the logical expressions connected by &amp; and</td>
      <td>must be inside parens, e.g. (a) &amp; (b).</td>
    </tr>
  </tbody>
</table>

<p>To create a DataFrame from scratch and then modify:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">()</span> <span class="c1"># makes an empty df
</span><span class="n">df</span><span class="p">[</span><span class="s">"newcol"</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_like_var</span> <span class="c1"># also df = pd.DataFrame({newcol: list_like_var})
</span><span class="n">df</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="s">"colname"</span><span class="p">)</span> <span class="c1">#removes column
</span></code></pre></div></div>

<p><code class="highlighter-rouge">df.sort_values()</code> sorts according to the index by default. Takes an optional parameter <code class="highlighter-rouge">by="colname"</code>
<code class="highlighter-rouge">df["col"].unique()</code> returns a np.array of unique elements
<code class="highlighter-rouge">df.drop_duplicates()</code> returns a df without repeated rows.</p>

<ul>
  <li>Has optional params subset = [“col1”, “col2”, …] to indicate the cols that determine uniqueness</li>
  <li>Has optional params inplace=True (like many other methods)</li>
</ul>

<p><code class="highlighter-rouge">df.itertuples()</code> iterates over rows as tuples, e.g.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">employees</span><span class="p">[</span><span class="s">'bonus'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">.</span><span class="n">salary</span> <span class="k">if</span> <span class="p">(</span><span class="n">row</span><span class="p">.</span><span class="n">employee_id</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lucky</span><span class="p">(</span><span class="n">row</span><span class="p">.</span><span class="n">name</span><span class="p">))</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">employees</span><span class="p">.</span><span class="n">itertuples</span><span class="p">()]</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">df["col"].apply(f)</code> applies <code class="highlighter-rouge">f</code> to each element of <code class="highlighter-rouge">df["col"]</code></p>

<p><code class="highlighter-rouge">pd.merge(df1, df2, on="col")</code> merges on the column.</p>

<ul>
  <li>If the column names are different then there is left_on= and right_on=.</li>
  <li>
    <p>By default, how=”inner” which means that rows that do not have a common value on “col” are dropped. There is also:</p>

    <ul>
      <li>how=”outer”: any extra rows are added with missing entries turned into NaN</li>
      <li>how=”left”: left outer, i.e. only extra rows from the left are added</li>
      <li>how=”right” similarly</li>
      <li>how=”cross”: creates a kronecker product of the two dfs.</li>
    </ul>
  </li>
  <li>df.rank() gives a float ranking based on the position after sorting. Optional param ascending=False: same as sorted(lst, reversed=True). There is a more complicated optional param called method:</li>
</ul>

<p>Suppose we have a dataframe called df with a column called ‘score’ that has the following values:
[10, 20, 20, 30, 40, 40, 40].
If we use df[‘score’].rank(method=’average’), the rank values will be:
[1.0, 2.5, 2.5, 4.0, 6.0, 6.0, 6.0].
This is because the average of the positions of the equal values is used as the rank. For example, the two values of 20 are in positions 2 and 3, so their rank is (2 + 3) / 2 = 2.5.
If we use df[‘score’].rank(method=’min’), the rank values will be:
[1.0, 2.0, 2.0, 4.0, 5.0, 5.0, 5.0].
This is because the minimum of the positions of the equal values is used as the rank. For example, the two values of 20 are in positions 2 and 3, so their rank is min(2, 3) = 2.
If we use df[‘score’].rank(method=’max’), the rank values will be:
[1.0, 3.0, 3.0, 4.0, 7.0, 7.0, 7.0].
This is because the maximum of the positions of the equal values is used as the rank. For example, the two values of 20 are in positions 2 and 3, so their rank is max(2, 3) = 3.
If we use df[‘score’].rank(method=’first’), the rank values will be:
[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0].
This is because the order of appearance of the equal values is used as the rank. For example, the two values of 20 are in positions 2 and 3, but the first one has a lower rank than the second one.
If we use df[‘score’].rank(method=’dense’), the rank values will be:
[1.0, 2.0, 2.0, 3.0, 4.0, 4.0, 4.0].
This is because the rank always increases by one between groups of equal values. For example, the two values of 20 have the same rank of 2, and the next value of 30 has a rank of 3.</p>

<ul>
  <li>
    <p>df.groupby(“col”) makes an intermediate object that is useful for further processing.</p>
  </li>
  <li>
    <p>df.melt and df.pivot are sort of inverses to each other.
The <code class="highlighter-rouge">melt</code> method takes four arguments: <code class="highlighter-rouge">id_vars</code>, <code class="highlighter-rouge">value_vars</code>, <code class="highlighter-rouge">var_name</code>, and <code class="highlighter-rouge">value_name</code>. These arguments specify which columns of the pivoted dataframe to use as the identifier variables, value variables, variable name, and value name of the melted dataframe, respectively. For example, if you have a pivoted dataframe like this:</p>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th>type</th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>label</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>x</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <td>y</td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
    </tr>
    <tr>
      <td>z</td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
    </tr>
  </tbody>
</table>

<p>You can <code class="highlighter-rouge">melt</code> like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">melted_df</span> <span class="o">=</span> <span class="n">pivoted_df</span><span class="p">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="s">'label'</span><span class="p">,</span> <span class="n">value_vars</span><span class="o">=</span><span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s">'type'</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s">'value'</span><span class="p">)</span>
</code></pre></div></div>

<p>The result will be a melted dataframe like this:</p>

<table>
  <thead>
    <tr>
      <th>label</th>
      <th>type</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>x</td>
      <td>a</td>
      <td>1</td>
    </tr>
    <tr>
      <td>x</td>
      <td>b</td>
      <td>2</td>
    </tr>
    <tr>
      <td>x</td>
      <td>c</td>
      <td>3</td>
    </tr>
    <tr>
      <td>y</td>
      <td>a</td>
      <td>4</td>
    </tr>
    <tr>
      <td>y</td>
      <td>b</td>
      <td>5</td>
    </tr>
    <tr>
      <td>y</td>
      <td>c</td>
      <td>6</td>
    </tr>
    <tr>
      <td>z</td>
      <td>a</td>
      <td>7</td>
    </tr>
    <tr>
      <td>z</td>
      <td>b</td>
      <td>8</td>
    </tr>
    <tr>
      <td>z</td>
      <td>c</td>
      <td>9</td>
    </tr>
  </tbody>
</table>

<p>and you can go back using</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pivoted_df</span> <span class="o">=</span> <span class="n">melted_df</span><span class="p">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s">'label'</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s">'type'</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s">'value'</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">df.reset_index()</code> turns the index back to the default (undos tuple indexing)</p>
:ET